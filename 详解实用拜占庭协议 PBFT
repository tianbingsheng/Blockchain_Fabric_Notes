PBFT 算法和 Raft 算法解决的核心问题都是在分布式环境下如何保持集群状态的一致性，简而言之就是一组服务，给定一组操作，最后得到一致的结果。

 PBFT 算法假设的环境又比 Raft 算法更加的’恶劣‘，Raft 算法只支持容错故障节点，而 PBFT 算法除了需要支持容错故障节点之外，还需要容忍作恶节点。

作恶节点节点是指可能对接收到的消息作出截然相反的回复，甚至伪造消息。

 PBFT 算法中节点只有两种角色，主节点（primary）和副本（replica），两种角色之间可以相互转换。两者之间的转换又引入了视图（view）的概念，视图在 PBFT 算法中起到逻辑时钟的作用。

  为了更多的容错性，PBFT 算法最大的容错节点数量 ( n - 1 ) / 3，也就是是说 4 个节点的集群最多只能容忍一个节点作恶或者故障。而 Raft 算法的最大容错节点是 ( n - 1) / 2，5 个节点的集群可以容忍 2 个节点故障。

为什么 PBFT 算法只能容忍 (n-1)/3 个作恶节点？
节点总数是 n，其中作恶节点有 f，那么剩下的正确节点为 n - f，意味着只要收到 n - f 个消息就能做出决定，但是这 n - f 个消息有可能由 f 个是由作恶节点冒充的，那么正确的消息就是 n - f - f 个，为了多数一致，正确消息必须占多数，也就是 n - f - f > f，但是节点必须是整数个，所以 n 最少是 3f+1 个。

或者可以这样理解，假定 f 个节点是故障节点，f 个节点是作恶，那么达成一致需要的正确节点最少就是 f+1 个，当然这是最坏的情况，如果故障节点集合和拜占庭节点集合有重复，可以不需要 f+1 个正确节点，但是为了保证最坏的情况算法还能正常运行，所以必须保证正确节点数量是 f+1 个。

算法流程
  在算法开始阶段，主节点由 p = v mod n 计算得出，随着 v 的增长可以看到 p 不断变化，论文里目前还是轮流坐庄的方法，这里是一个优化点。

  首先客户端发送消息 m 给主节点 p，主节点就开始了 PBFT 三阶段协议，三个阶段分别是预准备（pre-prepare），准备（prepare），提交（commit）。
  其中 pre-prepare 和 prepare 阶段最重要的任务是保证，同一个主节点发出的请求在同一个视图（view）中的顺序是一致的，prepare 和 commit 阶段最重要的任务是保证请求在不同视图之间的顺序是一致的。

主节点收到客户端发送来的消息后，构造 pre-prepare 消息结构体 < <PRE-PREPARE, v, n, d>, m > 广播到集群中的其它节点。
PRE-PREPARE 标识当前消息所处的协议阶段。
v 标识当前视图编号。
n 为主节点广播消息的一个唯一递增序号。
d 为 m 的消息摘要。
m 为客户端发来的消息。
副本(backup) 收到主节点请求后，会对消息进行检查，检查通过会存储在本节点。当节点收到 2f+1（包括自己）个相同的消息后，会进入 PREPARE 状态，广播消息 < <PREPARA, v, n, d, i> >，其中 i 是本节点的编号。对消息的有效性有如下检查：

检查收到的消息体中摘要 d，是否和自己对 m 生成的摘要一致，确保消息的完整性。
检查 v 是否和当前视图 v 一致。
检查序号 n 是否在水线 h 和 H 之间，避免快速消耗可用序号。
检查之前是否接收过相同序号 n 和 v，但是不同摘要 d 的消息。
副本收到 2f+1（包括自己）个一致的 PREPARE 消息后，会进入 COMMIT 阶段，并且广播消息 < COMMIT, v, n, D(m), i > 给集群中的其它节点。在收到 PREPARE 消息后，副本同样也会对消息进行有效性检查，检查的内容是上文 1, 2, 3。

副本收到 2f+1（包括自己）个一致的 COMMIT 个消息后执行 m 中包含的操作，其中，如果有多个 m 则按照序号 n 从小到大执行，执行完毕后发送执行成功的消息给客户端。

下面就是算法的流程图：

PBFT算法

日志压缩
  Pbft 算法在运行的过程中，日志会不断累积的，但是在实际的系统中，无论是从日志占用的磁盘空间，还是新节点加入集群，同步日志的网络消耗来看，日志都不能无限的增长。

  Pbft 采用检查点（checkpoint）机制来压缩日志，其本质和 Raft 算法采用快照的形式清理日志是一样的，只是实现的方式不同。

  为每一次操作创建一个集群中稳定检查点，代价是非常昂贵的，Pbft 为常数个操作创建一次稳定检查点，比如每 100 个操作创建一次检查点，而这个检查点就是 checkpoint，当这个 checkpoint 得到集群中多数节点认可以后，就变成了稳定检查点 stable checkpoint。

  当节点 i 生成 checkpoint 后会广播消息 <CHECKPOINT, n, d, i> 其中 n 是最后一次执行的消息序号，d 是 n 执行后的状态机状态的摘要。每个节点收到 2f+1 个相同 n 和 d 的 checkpoint 消息以后，checkpoint 就变成了 stable checkpoint。同时删除本地序号小于等于 n 的消息。

  同时 checkpoint 还有一个提高水线（water mark）的作用，当一个 stable checkpoint 被创建的时候，水线 h 被修改为 stable checkpoint 的 n，水线 H 为 h + k 而 k 就是之前用到创建 checkpoint 的那个常数。

视图切换（View-Change）
  在正常流程中，可以看到所有客户端发来的消息 m 都是由主节点 p 广播到集群的，但是当主节点突然宕机，又怎么保证集群的可用性呢？

  view-change 提供了一种当主节点宕机以后依然可以保证集群可用性的机制。view-change 通过计时器来进行切换，避免副本长时间的等待请求。
  当副本收到请求时，就启动一个计时器，如果这个时候刚好有定时器在运行就重置（reset）定时器，但是主节点宕机的时候，副本 i 就会在当前视图 v 中超时，这个时候副本 i 就会触发 view-change 的操作，将视图切换为 v+1。

副本 i 会停止接收除了 checkpoint，view-change 和 new view-change 以外的请求，同时广播消息 <VIEW-CHANGE, v+1, n, C, P, i> 的消息到集群。
n 是节点 i 知道的最后一个 stable checkpoint 的消息序号。
C 是节点 i 保存的经过 2f+1 个节点确认 stable checkpoint 消息的集合。
P 是一个保存了 n 之后所有已经达到 prepared 状态消息的集合。
当在视图 (v+1) 中的主节点 p1 接收到 2f 个有效的将视图变更为 v+1 的消息以后，p1 就会广播一条消息 <NEW-VIEW, v+1, V, Q>
V 是 p1 收到的，包括自己发送的 view-change 的消息集合。
Q 是 PRE-PREPARE 状态的消息集合，但是这个 PRE-PREPARE 消息是从 PREPARE 状态的消息转换过来的。
从节点接收到 NEW-VIEW 消息后，校验签名，V 和 Q 中的消息是否合法，验证通过，主节点和副本都 进入视图 v+1。
  当 p1 在接收到 2f+1 个 VIEW-CHANGE 消息以后，可以确定 stable checkpoint 之前的消息在视图切换的过程中不会丢，但是当前检查点之后，下一个检查点之前的已经 PREPARE 可能会被丢弃，在视图切换到 v+1 后，Pbft 会把旧视图中已经 PREPARE 的消息变为 PRE-PREPARE 然后新广播。

如果集合 P 为空，广播 <PRE-PREPARE, v+1, n, null>，接收节点就什么也不做。
如果集合 P 不为空，广播 <PRE-PREPARE, v+1, n,d>
  总结一下，在 view-change 中最为重要的就是 C，P，Q 三个消息的集合，C 确保了视图变更的时候，stable checkpoint 之前的状态安全。P 确保了视图变更前，已经 PREPARE 的消息的安全。Q 确保了视图变更后 P 集合中的消息安全。回想一下 pre-prepare 和 prepare 阶段最重要的任务是保证，同一个主节点发出的请求在同一个视图（view）中的顺序是一致的，而在视图切换过程中的 C，P，Q 三个集合就是解决这个问题的。
